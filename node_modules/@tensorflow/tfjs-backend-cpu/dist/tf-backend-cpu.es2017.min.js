/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@tensorflow/tfjs-core"),require("seedrandom")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core","seedrandom"],e):e((t=t||self).tf=t.tf||{},t.tf,t.seedrandom)}(this,(function(t,e,a){"use strict";function r(t,a){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&e.util.assert("complex64"!==t.dtype,()=>`${a} does not support complex64 tensors in the CPU backend.`)})}function n(t,a,r,n,s,o){const i=s.strideHeight,l=s.strideWidth,d=s.dilationHeight,h=s.dilationWidth,c=s.effectiveFilterHeight,u=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,m="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,y=e.buffer(s.outShape,r),g=y.values,S=s.outShape[1]*s.outShape[2]*s.outShape[3],I=s.outShape[2]*s.outShape[3],b=s.outShape[3];for(let e=0;e<s.batchSize;++e){const a=e*S,r=e*n[0];for(let e=0;e<s.inChannels;++e)for(let y=0;y<s.outHeight;++y){const S=y*i-p,k=Math.max(0,S),M=Math.min(s.inHeight,c+S),x=a+y*I;for(let a=0;a<s.outWidth;++a){const i=a*l-f,c=Math.max(0,i),p=Math.min(s.inWidth,u+i);let y=m,S=0,I=0;for(let a=k;a<M;a+=d){const s=r+a*n[1];for(let a=c;a<p;a+=h){const r=t[s+a*n[2]+e];"max"===o&&r>y?y=r:"avg"===o&&(S+=r,I++)}if(isNaN(y))break}g[x+a*b+e]="avg"===o?S/I:y}}}return y}function s(t,a,r,n,s=!1,o=!1){const i=e.buffer(n.outShape,"int32"),l=n.strideHeight,d=n.strideWidth,h=n.dilationHeight,c=n.dilationWidth,u=n.effectiveFilterHeight,p=n.effectiveFilterWidth,f=n.padInfo.top,m=n.padInfo.left,y=e.buffer(a,r,t);for(let t=0;t<n.batchSize;++t)for(let e=0;e<n.inChannels;++e)for(let a=0;a<n.outHeight;++a){const r=a*l-f;let g=r;for(;g<0;)g+=h;const S=Math.min(n.inHeight,u+r);for(let l=0;l<n.outWidth;++l){const u=l*d-m;let f=u;for(;f<0;)f+=c;const I=Math.min(n.inWidth,p+u);let b=Number.NEGATIVE_INFINITY,k=-1;for(let a=g;a<S;a+=h){const i=a-r;for(let r=f;r<I;r+=c){const l=r-u,d=y.get(t,a,r,e);d>b&&(b=d,k=s?o?((t*n.inHeight+a)*n.inWidth+r)*n.inChannels+e:(a*n.inWidth+r)*n.inChannels+e:i*p+l)}}i.set(k,t,a,l,e)}}return i}const o=e.kernel_impls.nonMaxSuppressionV3Impl,i=e.kernel_impls.split,l=e.kernel_impls.tile,d=e.kernel_impls.topkImpl,h=e.kernel_impls.whereImpl;function c(t,e,a,r){if("linear"===a)return t.linear(e);if("relu"===a)return t.relu(e);if("elu"===a)return t.elu(e);if("relu6"===a)return t.relu6(e);if("prelu"===a)return t.prelu(e,r);throw new Error(`Activation ${a} has not been implemented for the CPU backend.`)}class u extends e.KernelBackend{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new e.DataStorage(this,e.engine())}write(t,a,r){this.firstUse&&(this.firstUse=!1,e.env().get("IS_NODE")&&e.backend_util.warn("\n============================\nHi there ðŸ‘‹. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const n={};return this.data.set(n,{values:t,dtype:r}),n}move(t,e,a,r){this.data.set(t,{values:e,dtype:r})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:a,complexTensors:r}=this.data.get(t);if("complex64"===a){const t=this.readSync(r.real.dataId),a=this.readSync(r.imag.dataId);return e.backend_util.mergeRealAndImagArrays(t,a)}return this.data.get(t).values}bufferSync(t){const a=this.readSync(t.dataId);let r=a;if("string"===t.dtype)try{r=a.map(t=>e.util.decodeString(t))}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}return e.buffer(t.shape,t.dtype,r)}makeOutput(t,a,r){const n=this.write(t,a,r);return e.engine().makeTensorFromDataId(n,a,r,this)}disposeData(t){if(this.data.has(t)){const{complexTensors:e}=this.data.get(t);null!=e&&(e.real.dispose(),e.imag.dispose()),this.data.delete(t)}}async time(t){const a=e.util.now();return t(),{kernelMs:e.util.now()-a}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}complex(t,a){const r=this.makeOutput(null,t.shape,"complex64");return this.data.get(r.dataId).complexTensors={real:e.engine().keep(t.clone()),imag:e.engine().keep(a.clone())},r}real(t){return this.data.get(t.dataId).complexTensors.real.clone()}imag(t){return this.data.get(t.dataId).complexTensors.imag.clone()}slice(t,a,n){if(r(t,"slice"),e.slice_util.isSliceContinous(t.shape,a,n)){const r=e.slice_util.computeFlatOffset(a,t.strides),s=e.util.sizeFromShape(n),o=this.readSync(t.dataId);return e.tensor(o.subarray(r,r+s),n,t.dtype)}const s=e.buffer(n,t.dtype),o=this.bufferSync(t);for(let t=0;t<s.size;++t){const e=s.indexToLoc(t).map((t,e)=>t+a[e]);s.values[t]=o.get(...e)}return s.toTensor()}stridedSlice(t,a,n,s){r(t,"stridedSlice");const o=e.slice_util.computeOutShape(a,n,s);if(o.some(t=>0===t))return e.tensor([],o);const i=e.buffer(o,t.dtype),l=this.bufferSync(t);for(let t=0;t<i.size;t++){const e=i.indexToLoc(t),r=new Array(e.length);for(let t=0;t<r.length;t++)r[t]=e[t]*s[t]+a[t];i.set(l.get(...r),...e)}return i.toTensor()}diag(t){const a=this.readSync(t.dataId),r=e.buffer([t.size,t.size],t.dtype),n=r.values;for(let e=0;e<a.length;e++)n[e*t.size+e]=a[e];return r.toTensor()}unstack(t,e){const a=t.shape[e],r=new Array(t.rank-1);let n=0;for(let a=0;a<t.rank;a++)a!==e&&(r[n++]=t.shape[a]);const s=new Array(t.rank).fill(0),o=t.shape.slice();o[e]=1;const i=new Array(a);for(let a=0;a<i.length;a++)s[e]=a,i[a]=this.slice(t,s,o).reshape(r);return i}reverse(t,a){r(t,"reverse");const n=e.buffer(t.shape,t.dtype),s=this.bufferSync(t);for(let e=0;e<n.size;e++){const r=n.indexToLoc(e),o=r.slice();a.forEach(e=>o[e]=t.shape[e]-1-o[e]),n.set(s.get(...o),...r)}return n.toTensor()}concat(t,a){if("complex64"===t[0].dtype){const r=t.map(t=>e.real(t)),n=t.map(t=>e.imag(t));return e.complex(this.concat(r,a),this.concat(n,a))}const r=t.map(t=>{const r=e.util.sizeFromShape(t.shape.slice(a));return t.as2D(-1,r)}),n=e.backend_util.computeOutShape(r.map(t=>t.shape),1),s=e.buffer(n,t[0].dtype).values;if(1===r[0].shape[0]){let t=0;r.forEach(e=>{s.set(this.readSync(e.dataId),t),t+=e.size})}else{let t=0;r.forEach(e=>{const a=this.readSync(e.dataId);let r=0;for(let o=0;o<e.shape[0];++o){const i=o*n[1]+t;for(let t=0;t<e.shape[1];++t)s[i+t]=a[r++]}t+=e.shape[1]})}const o=e.backend_util.computeOutShape(t.map(t=>t.shape),a);return e.tensor(s,o,t[0].dtype)}neg(t){return r(t,"neg"),this.multiply(e.scalar(-1),t)}add(t,a){return"complex64"===t.dtype||"complex64"===a.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),a.cast("complex64"),(t,e,a,r)=>({real:t+a,imag:e+r})):this.broadcastedBinaryOp(t,a,e.upcastType(t.dtype,a.dtype),(t,e)=>t+e)}addN(t){r(t,"addN");const a=t.map(t=>this.readSync(t.dataId)),n=e.buffer(t[0].shape,t[0].dtype),s=n.values;for(let e=0;e<t.length;e++){const t=a[e];for(let e=0;e<s.length;e++)s[e]+=t[e]}return n.toTensor()}softmax(t,a){const r=e.util.parseAxisParam([a],t.shape),n=e.max(t,r),s=e.backend_util.expandShapeToKeepDim(n.shape,r),o=this.subtract(t,n.reshape(s)),i=this.exp(o),l=this.sum(i,r).reshape(s);return e.div(i,l)}subtract(t,a){return"complex64"===t.dtype||"complex64"===a.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),a.cast("complex64"),(t,e,a,r)=>({real:t-a,imag:e-r})):this.broadcastedBinaryOp(t,a,e.upcastType(t.dtype,a.dtype),(t,e)=>t-e)}pow(t,e){return r([t,e],"pow"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.pow(t,e))}batchMatMul(t,a,n,s){r([t,a],"matMul");const o=n?t.shape[1]:t.shape[2],i=n?t.shape[2]:t.shape[1],l=s?a.shape[1]:a.shape[2],d=t.shape[0],h=this.readSync(t.dataId),c=this.readSync(a.dataId),[u,p,f]=n?[t.strides[0],1,t.strides[1]]:[t.strides[0],t.strides[1],1],[m,y,g]=s?[1,a.strides[1],a.strides[0]]:[a.strides[1],1,a.strides[0]],S=i*l,I=e.buffer([d,i,l],t.dtype),b=I.values,k=this.blockSize;for(let t=0;t<d;t++)for(let e=0;e<i;e+=k)for(let a=0;a<l;a+=k)for(let r=0;r<o;r+=k){const n=Math.min(e+k,i),s=Math.min(a+k,l),d=Math.min(r+k,o);for(let o=e;o<n;o++)for(let e=a;e<s;e++){let a=0;for(let n=r;n<d;n++)a+=h[t*u+o*p+n*f]*c[n*m+e*y+t*g];b[t*S+(o*l+e)]+=a}}return I.toTensor()}fusedBatchMatMul({a:t,b:e,transposeA:a,transposeB:r,bias:n,activation:s,preluActivationWeights:o}){let i=this.batchMatMul(t,e,a,r);return n&&(i=this.add(i,n)),s&&(i=c(this,i,s,o)),i}multiply(t,a){return"complex64"===t.dtype||"complex64"===a.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),a.cast("complex64"),(t,e,a,r)=>({real:t*a-e*r,imag:t*r+e*a})):this.broadcastedBinaryOp(t,a,e.upcastType(t.dtype,a.dtype),(t,e)=>t*e)}floorDiv(t,e){r([t,e],"floorDiv");return this.broadcastedBinaryOp(t,e,"int32",(t,e)=>Math.floor(t/e))}sum(t,a){r(t,"sum"),e.backend_util.assertAxesAreInnerMostDims("sum",a,t.rank);const[n,s]=e.backend_util.computeOutAndReduceShapes(t.shape,a),o=e.upcastType(t.dtype,"int32"),i=e.zeros(n,o),l=e.util.sizeFromShape(s),d=this.readSync(i.dataId),h=this.readSync(t.dataId);for(let t=0;t<d.length;++t){const e=t*l;let a=0;for(let t=0;t<l;++t)a+=h[e+t];d[t]=a}return i}prod(t,a){r(t,"sum");const[n,s]=e.backend_util.computeOutAndReduceShapes(t.shape,a),o=e.upcastType(t.dtype,"int32"),i=e.zeros(n,o),l=e.util.sizeFromShape(s),d=this.readSync(i.dataId),h=this.readSync(t.dataId);for(let t=0;t<d.length;++t){const e=t*l;let a=1;for(let t=0;t<l;++t)a*=h[e+t];d[t]=a}return i}unsortedSegmentSum(t,a,n){r(t,"unsortedSegmentSum");const s=[],o=t.rank-a.rank;for(let t=0;t<o;++t)a=a.expandDims(t+1);for(let r=0;r<n;++r){const n=e.scalar(r,"int32"),o=e.equal(n,a).asType("float32").mul(t).sum(0);s.push(o)}return e.stack(s)}argMin(t,a){r(t,"argMin");const n=[a];e.backend_util.assertAxesAreInnerMostDims("argMin",n,t.rank);const[s,o]=e.backend_util.computeOutAndReduceShapes(t.shape,n),i=e.zeros(s,"int32"),l=e.util.sizeFromShape(o),d=this.readSync(i.dataId),h=this.readSync(t.dataId);for(let t=0;t<d.length;++t){const e=t*l;let a=h[e],r=0;for(let t=0;t<l;++t){const n=h[e+t];n<a&&(a=n,r=t)}d[t]=r}return i}argMax(t,a){r(t,"argMax");const n=[a];e.backend_util.assertAxesAreInnerMostDims("argMax",n,t.rank);const[s,o]=e.backend_util.computeOutAndReduceShapes(t.shape,n),i=e.zeros(s,"int32"),l=e.util.sizeFromShape(o),d=this.readSync(i.dataId),h=this.readSync(t.dataId);for(let t=0;t<d.length;++t){const e=t*l;let a=h[e],r=0;for(let t=0;t<l;++t){const n=h[e+t];n>a&&(a=n,r=t)}d[t]=r}return i}cumsum(t,a,n,s){if(r(t,"cumsum"),a!==t.rank-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${t.rank-1} `+`but got axis=${a}`);const o=e.upcastType(t.dtype,"int32"),i=e.zeros(t.shape,o),l=this.readSync(i.dataId),d=this.readSync(t.dataId),h=t.shape[t.rank-1],c=s?(t,e)=>t+h-e-1:(t,e)=>t+e;for(let t=0;t<d.length;t+=h)for(let e=0;e<h;e++){const a=c(t,e);if(0===e)l[a]=n?0:d[a];else{const r=c(t,e-1);l[a]=n?d[r]+l[r]:d[a]+l[r]}}return i}equal(t,e){return r([t,e],"equal"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t===e?1:0)}notEqual(t,e){return r([t,e],"notEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t!==e?1:0)}less(t,e){return r([t,e],"less"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t<e?1:0)}lessEqual(t,e){return r([t,e],"lessEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t<=e?1:0)}greater(t,e){return r([t,e],"greater"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t>e?1:0)}greaterEqual(t,e){return r([t,e],"greaterEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t>=e?1:0)}logicalNot(t){r(t,"logicalNot");const e=this.readSync(t.dataId),a=new Uint8Array(e.length);for(let t=0;t<e.length;++t)a[t]=e[t]?0:1;return this.makeOutput(a,t.shape,"bool")}logicalAnd(t,e){return r([t,e],"logicalAnd"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t&&e)}logicalOr(t,e){return r([t,e],"logicalOr"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t||e)}select(t,a,n){r([t,a,n],"select");const s=this.readSync(t.dataId),o=this.readSync(a.dataId),i=this.readSync(n.dataId),l=e.zeros(a.shape,e.upcastType(a.dtype,n.dtype)),d=this.readSync(l.dataId);let h=0;const c=0===t.rank||t.rank>1||1===a.rank?1:e.util.sizeFromShape(a.shape.slice(1));for(let t=0;t<s.length;t++)for(let e=0;e<c;e++)1===s[t]?d[h++]=o[t]:d[h++]=i[t];return l}where(t){r([t],"where");const e=this.readSync(t.dataId);return h(t.shape,e)}topk(t,e,a){r(t,"topk");const n=this.readSync(t.dataId);return d(n,t.shape,t.dtype,e,a)}min(t,a){r(t,"min"),e.backend_util.assertAxesAreInnerMostDims("min",a,t.rank);const[n,s]=e.backend_util.computeOutAndReduceShapes(t.shape,a),o=e.zeros(n,t.dtype),i=e.util.sizeFromShape(s),l=this.readSync(o.dataId),d=this.readSync(t.dataId);for(let t=0;t<l.length;++t){const e=t*i;let a=d[e];for(let t=0;t<i;++t){const r=d[e+t];r<a&&(a=r)}l[t]=a}return o}minimum(t,e){return r([t,e],"minimum"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.min(t,e))}mod(t,e){return r([t,e],"mod"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>{const a=t%e;return t<0&&e<0||t>=0&&e>=0?a:(a+e)%e})}maximum(t,e){return r([t,e],"maximum"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.max(t,e))}all(t,a){r(t,"all"),e.backend_util.assertAxesAreInnerMostDims("all",a,t.rank);const[n,s]=e.backend_util.computeOutAndReduceShapes(t.shape,a),o=e.zeros(n,t.dtype),i=e.util.sizeFromShape(s),l=this.readSync(o.dataId),d=this.readSync(t.dataId);for(let t=0;t<l.length;++t){const e=t*i;let a=d[e];for(let t=0;t<i;++t){const r=d[e+t];a=a&&r}l[t]=a}return o}any(t,a){r(t,"any"),e.backend_util.assertAxesAreInnerMostDims("any",a,t.rank);const[n,s]=e.backend_util.computeOutAndReduceShapes(t.shape,a),o=e.zeros(n,t.dtype),i=e.util.sizeFromShape(s),l=this.readSync(o.dataId),d=this.readSync(t.dataId);for(let t=0;t<l.length;++t){const e=t*i;let a=d[e];for(let t=0;t<i;++t){const r=d[e+t];a=a||r}l[t]=a}return o}squaredDifference(t,e){return r([t,e],"squaredDifference"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>{const a=t-e;return a*a})}ceil(t){r(t,"ceil");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=Math.ceil(e[t]);return this.makeOutput(a,t.shape,"float32")}floor(t){r(t,"floor");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=Math.floor(e[t]);return this.makeOutput(a,t.shape,"float32")}sign(t){r(t,"x");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)e[t]<0?a[t]=-1:e[t]>0?a[t]=1:a[t]=0;return this.makeOutput(a,t.shape,"float32")}isNaN(t){r(t,"x");const e=this.readSync(t.dataId),a=new Uint8Array(e.length);for(let t=0;t<e.length;++t)Number.isNaN(e[t])&&(a[t]=1);return this.makeOutput(a,t.shape,"bool")}isInf(t){r(t,"x");const e=this.readSync(t.dataId),a=new Uint8Array(e.length);for(let t=0;t<e.length;++t)Math.abs(e[t])===1/0&&(a[t]=1);return this.makeOutput(a,t.shape,"bool")}isFinite(t){r(t,"x");const e=this.readSync(t.dataId),a=new Uint8Array(e.length);for(let t=0;t<e.length;++t)Number.isFinite(e[t])&&(a[t]=1);return this.makeOutput(a,t.shape,"bool")}round(t){r(t,"round");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=Math.floor(e[t]);e[t]-r<.5?a[t]=Math.floor(e[t]):e[t]-r>.5?a[t]=Math.ceil(e[t]):a[t]=r%2==0?r:r+1}return this.makeOutput(a,t.shape,"float32")}exp(t){r(t,"exp");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=Math.exp(e[t]);return this.makeOutput(a,t.shape,"float32")}expm1(t){r(t,"expm1");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=Math.expm1(e[t]);return this.makeOutput(a,t.shape,"float32")}log(t){r(t,"log");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=e[t];a[t]=Math.log(r)}return this.makeOutput(a,t.shape,"float32")}log1p(t){r(t,"log1p");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=e[t];a[t]=Math.log1p(r)}return this.makeOutput(a,t.shape,"float32")}sqrt(t){r(t,"sqrt");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=e[t];a[t]=Math.sqrt(r)}return this.makeOutput(a,t.shape,"float32")}rsqrt(t){r(t,"rsqrt");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=e[t];a[t]=1/Math.sqrt(r)}return this.makeOutput(a,t.shape,"float32")}reciprocal(t){r(t,"reciprocal");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=1/e[t];return this.makeOutput(a,t.shape,"float32")}linear(t){return t}relu(t){r(t,"relu");const a=e.zeros(t.shape,t.dtype),n=this.readSync(a.dataId),s=this.readSync(t.dataId);for(let t=0;t<s.length;++t)n[t]=Math.max(0,s[t]);return a}relu6(t){r(t,"relu");const a=e.zeros(t.shape,t.dtype),n=this.readSync(a.dataId),s=this.readSync(t.dataId);for(let t=0;t<s.length;++t)n[t]=Math.min(Math.max(0,s[t]),6);return a}prelu(t,e){return r([t,e],"prelu"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>t<0?e*t:t)}elu(t){r(t,"elu");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t){const r=a[t];e[t]=r>=0?r:Math.exp(r)-1}return this.makeOutput(e,t.shape,"float32")}eluDer(t,e){r([t,e],"eluDer");const a=new Float32Array(e.size),n=this.readSync(e.dataId),s=this.readSync(t.dataId);for(let t=0;t<n.length;++t){const e=n[t];a[t]=e>=1?s[t]:s[t]*(e+1)}return this.makeOutput(a,e.shape,"float32")}selu(t){r(t,"selu");const a=e.backend_util.SELU_SCALEALPHA,n=e.backend_util.SELU_SCALE,s=new Float32Array(t.size),o=this.readSync(t.dataId);for(let t=0;t<o.length;++t){const e=o[t];s[t]=e>=0?n*e:a*(Math.exp(e)-1)}return this.makeOutput(s,t.shape,"float32")}clip(t,e,a){r(t,"clip");const n=new Float32Array(t.size),s=this.readSync(t.dataId);for(let t=0;t<s.length;++t){const r=s[t];n[t]=r>a?a:r<e?e:r}return this.makeOutput(n,t.shape,"float32")}abs(t){const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.abs(a[t]);return this.makeOutput(e,t.shape,"float32")}complexAbs(t){const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let r=0;r<t.size;++r){const t=a[2*r],n=a[2*r+1];e[r]=Math.hypot(t,n)}return this.makeOutput(e,t.shape,"float32")}int(t){r(t,"int");const e=new Int32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=a[t];return this.makeOutput(e,t.shape,"int32")}sigmoid(t){r(t,"sigmoid");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=1/(1+Math.exp(-a[t]));return this.makeOutput(e,t.shape,"float32")}softplus(t){r(t,"softplus");const e=Math.log(1.1920928955078125e-7)+2,a=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t){const r=n[t]>-e,s=n[t]<e,o=Math.exp(n[t]);let i;i=s?o:r?n[t]:Math.log(1+o),a[t]=i}return this.makeOutput(a,t.shape,"float32")}sin(t){r(t,"sin");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.sin(a[t]);return this.makeOutput(e,t.shape,"float32")}cos(t){r(t,"cos");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.cos(a[t]);return this.makeOutput(e,t.shape,"float32")}tan(t){r(t,"tan");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.tan(a[t]);return this.makeOutput(e,t.shape,"float32")}asin(t){r(t,"asin");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.asin(a[t]);return this.makeOutput(e,t.shape,"float32")}acos(t){r(t,"acos");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.acos(a[t]);return this.makeOutput(e,t.shape,"float32")}atan(t){r(t,"atan");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.atan(a[t]);return this.makeOutput(e,t.shape,"float32")}atan2(t,e){return r([t,e],"atan2"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.atan2(t,e))}sinh(t){r(t,"sinh");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.sinh(a[t]);return this.makeOutput(e,t.shape,"float32")}cosh(t){r(t,"cosh");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.cosh(a[t]);return this.makeOutput(e,t.shape,"float32")}tanh(t){r(t,"tanh");const a=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)a[t]=e.util.tanh(n[t]);return this.makeOutput(a,t.shape,"float32")}asinh(t){r(t,"asinh");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.asinh(a[t]);return this.makeOutput(e,t.shape,"float32")}acosh(t){r(t,"acosh");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.acosh(a[t]);return this.makeOutput(e,t.shape,"float32")}atanh(t){r(t,"atanh");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.atanh(a[t]);return this.makeOutput(e,t.shape,"float32")}erf(t){r(t,"erf");const a=new Float32Array(t.size),n=this.readSync(t.dataId),s=e.backend_util.ERF_P,o=e.backend_util.ERF_A1,i=e.backend_util.ERF_A2,l=e.backend_util.ERF_A3,d=e.backend_util.ERF_A4,h=e.backend_util.ERF_A5;for(let t=0;t<n.length;++t){const e=Math.sign(n[t]),r=Math.abs(n[t]),c=1/(1+s*r);a[t]=e*(1-((((h*c+d)*c+l)*c+i)*c+o)*c*Math.exp(-r*r))}return this.makeOutput(a,t.shape,"float32")}step(t,e=0){r(t,"step");const a=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t){const r=n[t];isNaN(r)?a[t]=NaN:a[t]=r>0?1:e}return this.makeOutput(a,t.shape,"float32")}fusedConv2d({input:t,filter:e,convInfo:a,bias:r,activation:n,preluActivationWeights:s}){let o=this.conv2d(t,e,a);return r&&(o=this.add(o,r)),n&&(o=c(this,o,n,s)),o}conv2d(t,a,n){r([t,a],"conv2d");const s=n.filterHeight,o=n.filterWidth,i=n.dilationHeight,l=n.dilationWidth,d=n.padInfo.left,h=n.padInfo.top,c="channelsLast"===n.dataFormat,u=e.buffer(n.outShape,t.dtype),p=t.strides[0],f=c?t.strides[1]:t.strides[2],m=c?t.strides[2]:1,y=c?1:t.strides[1],g=u.strides[0],S=c?u.strides[1]:u.strides[2],I=c?u.strides[2]:1,b=c?1:u.strides[1],k=this.readSync(t.dataId),M=this.readSync(a.dataId),x=u.values;for(let t=0;t<n.batchSize;++t){const e=t*p,r=t*g;for(let t=0;t<n.outHeight;++t){const c=r+t*S,u=t*n.strideHeight-h;for(let t=0;t<s;t++){const r=u+t*i;if(r<0||r>=n.inHeight)continue;const s=t*a.strides[0],h=e+r*f;for(let t=0;t<n.outWidth;++t){const e=c+t*I,r=t*n.strideWidth-d;for(let t=0;t<o;t++){const o=r+t*l;if(o<0||o>=n.inWidth)continue;const i=h+o*m;let d=s+t*a.strides[1];for(let t=0;t<n.inChannels;++t){const a=k[i+t*y];for(let t=0;t<n.outChannels;++t)x[e+t*b]+=a*M[d+t];d+=n.outChannels}}}}}}return u.toTensor()}conv3d(t,a,r){const n=r.filterDepth,s=r.filterHeight,o=r.filterWidth,i=r.dilationDepth,l=r.dilationHeight,d=r.dilationWidth,h=r.padInfo.front,c=r.padInfo.left,u=r.padInfo.top,p=e.buffer(r.outShape,t.dtype),f=this.readSync(t.dataId),m=this.readSync(a.dataId),y=p.values;for(let e=0;e<r.batchSize;++e){const g=e*t.strides[0],S=e*p.strides[0];for(let e=0;e<r.outDepth;++e){const I=S+e*p.strides[1],b=e*r.strideDepth-h;for(let e=0;e<n;e++){const n=b+e*i;if(n<0||n>=r.inDepth)continue;const h=e*a.strides[0],S=g+n*t.strides[1];for(let e=0;e<r.outHeight;++e){const n=I+e*p.strides[2],i=e*r.strideHeight-u;for(let e=0;e<s;e++){const s=i+e*l;if(s<0||s>=r.inHeight)continue;const u=h+e*a.strides[1],p=S+s*t.strides[2];for(let t=0;t<r.outWidth;++t){const e=n+t*r.outChannels,s=t*r.strideWidth-c;for(let t=0;t<o;t++){const n=s+t*d;if(n<0||n>=r.inWidth)continue;const o=u+t*a.strides[2],i=p+n*r.inChannels;let l=o;for(let t=0;t<r.inChannels;++t){const a=f[i+t];for(let t=0;t<r.outChannels;++t)y[e+t]+=a*m[l+t];l+=r.outChannels}}}}}}}}return p.toTensor()}conv2dDerInput(t,a,n){r([t,a],"conv2dDerInput");const s=e.buffer(n.inShape,"float32"),o=s.values,i=this.readSync(t.dataId),l=this.readSync(a.dataId),[d,h,c]=a.strides,{batchSize:u,filterHeight:p,filterWidth:f,inChannels:m,inHeight:y,inWidth:g,outChannels:S,outHeight:I,outWidth:b,strideHeight:k,strideWidth:M,dataFormat:x}=n,A=p-1-n.padInfo.top,F=f-1-n.padInfo.left,v="channelsLast"===x,D=s.strides[0],T=v?s.strides[1]:s.strides[2],N=v?s.strides[2]:1,w=v?1:s.strides[1],z=t.strides[0],W=v?t.strides[1]:t.strides[2],H=v?t.strides[2]:1,_=v?1:t.strides[1];for(let t=0;t<u;++t)for(let e=0;e<m;++e)for(let a=0;a<y;++a){const r=a-A,n=Math.max(0,Math.ceil(r/k)),s=Math.min(I,(p+r)/k);for(let u=0;u<g;++u){const m=u-F,y=Math.max(0,Math.ceil(m/M)),g=Math.min(b,(f+m)/M);let I=0;for(let a=n;a<s;++a){const n=a*k-r;for(let r=y;r<g;++r){const s=z*t+W*a+H*r,o=d*(p-1-n)+h*(f-1-(r*M-m))+c*e;for(let t=0;t<S;++t){I+=i[s+_*t]*l[o+t]}}}o[D*t+T*a+N*u+w*e]=I}}return s.toTensor()}conv3dDerInput(t,a,r){const n=e.buffer(r.inShape,"float32"),s=n.values,[o,i,l,d]=n.strides,h=this.readSync(t.dataId),[c,u,p,f]=t.strides,m=this.readSync(a.dataId),[y,g,S,I]=a.strides,{batchSize:b,filterDepth:k,filterHeight:M,filterWidth:x,inChannels:A,inDepth:F,inHeight:v,inWidth:D,outChannels:T,outDepth:N,outHeight:w,outWidth:z,strideDepth:W,strideHeight:H,strideWidth:_}=r,O=k-1-r.padInfo.front,C=M-1-r.padInfo.top,B=x-1-r.padInfo.left;for(let t=0;t<b;++t)for(let e=0;e<A;++e)for(let a=0;a<F;++a){const r=a-O,n=Math.max(0,Math.ceil(r/W)),b=Math.min(N,(k+r)/W);for(let A=0;A<v;++A){const F=A-C,v=Math.max(0,Math.ceil(F/H)),N=Math.min(w,(M+F)/H);for(let w=0;w<D;++w){const D=w-B,O=Math.max(0,Math.ceil(D/_)),C=Math.min(z,(x+D)/_);let E=0;for(let a=n;a<b;++a){const n=a*W-r;for(let r=v;r<N;++r){const s=r*H-F;for(let o=O;o<C;++o){const i=c*t+u*a+p*r+f*o,l=y*(k-1-n)+g*(M-1-s)+S*(x-1-(o*_-D))+I*e;for(let t=0;t<T;++t){E+=h[i+t]*m[l+t]}}}}s[o*t+i*a+l*A+d*w+e]=E}}}return n.toTensor()}conv2dDerFilter(t,a,n){r([t,a],"conv2dDerFilter");const s=n.strideHeight,o=n.strideWidth,i=n.filterHeight,l=n.filterWidth,d="channelsLast"===n.dataFormat,h=e.buffer(n.filterShape,"float32"),c=n.padInfo.left,u=n.padInfo.top,p=this.bufferSync(t),f=this.bufferSync(a);for(let t=0;t<i;++t){const e=Math.max(0,Math.ceil((u-t)/s)),a=Math.min(n.outHeight,(n.inHeight+u-t)/s);for(let r=0;r<l;++r){const i=Math.max(0,Math.ceil((c-r)/o)),l=Math.min(n.outWidth,(n.inWidth+c-r)/o);for(let m=0;m<n.inChannels;++m)for(let y=0;y<n.outChannels;++y){let g=0;for(let h=0;h<n.batchSize;++h)for(let n=e;n<a;++n){const e=t+n*s-u;for(let t=i;t<l;++t){const a=r+t*o-c;g+=d?p.get(h,e,a,m)*f.get(h,n,t,y):p.get(h,m,e,a)*f.get(h,y,n,t)}}h.set(g,t,r,m,y)}}}return h.toTensor()}conv3dDerFilter(t,a,r){const n=r.strideDepth,s=r.strideHeight,o=r.strideWidth,i=r.filterDepth,l=r.filterHeight,d=r.filterWidth,h=e.buffer(r.filterShape,"float32"),c=h.values,[u,p,f,m]=h.strides,y=this.readSync(a.dataId),[g,S,I,b]=a.strides,k=this.readSync(t.dataId),[M,x,A,F]=t.strides,v=r.padInfo.front,D=r.padInfo.left,T=r.padInfo.top;for(let t=0;t<i;++t){const e=Math.max(0,Math.ceil((v-t)/n)),a=Math.min(r.outDepth,(r.inDepth+v-t)/n),i=t*u;for(let h=0;h<l;++h){const l=Math.max(0,Math.ceil((T-h)/s)),u=Math.min(r.outHeight,(r.inHeight+T-h)/s),N=h*p+i;for(let i=0;i<d;++i){const d=Math.max(0,Math.ceil((D-i)/o)),p=Math.min(r.outWidth,(r.inWidth+D-i)/o),w=i*f+N;for(let f=0;f<r.inChannels;++f){const N=f*m+w;for(let m=0;m<r.outChannels;++m){let w=0;for(let c=0;c<r.batchSize;++c){const r=c*M,N=c*g;for(let c=e;c<a;++c){const e=(t+c*n-v)*x+r,a=c*S+N;for(let t=l;t<u;++t){const r=(h+t*s-T)*A+e,n=t*I+a;for(let t=d;t<p;++t){const e=t*b+n;w+=k[(i+t*o-D)*F+r+f]*y[e+m]}}}}c[N+m]=w}}}}}return h.toTensor()}fusedDepthwiseConv2D({input:t,filter:e,convInfo:a,bias:r,activation:n,preluActivationWeights:s}){let o=this.depthwiseConv2D(t,e,a);return r&&(o=this.add(o,r)),n&&(o=c(this,o,n,s)),o}depthwiseConv2D(t,a,n){r([t,a],"depthwiseConv2D");const s=n.filterHeight,o=n.filterWidth,i=n.dilationHeight,l=n.dilationWidth,d=n.padInfo.left,h=n.padInfo.top,c=n.outChannels/n.inChannels,u=e.buffer(n.outShape,t.dtype),p=this.readSync(t.dataId),f=this.readSync(a.dataId),m=u.values;for(let e=0;e<n.batchSize;++e){const r=e*t.strides[0],y=e*u.strides[0];for(let e=0;e<n.outHeight;++e){const g=y+e*u.strides[1],S=e*n.strideHeight-d;for(let e=0;e<s;++e){const s=S+e*i;if(s<0||s>=n.inHeight)continue;const d=e*a.strides[0],y=r+s*t.strides[1];for(let t=0;t<n.outWidth;++t){const e=g+t*u.strides[2],r=t*n.strideWidth-h;for(let t=0;t<o;++t){const s=r+t*l;if(s<0||s>=n.inWidth)continue;const o=d+t*a.strides[1],i=y+s*n.inChannels;let h=e,u=o;for(let t=0;t<n.inChannels;++t){const e=p[i+t];for(let t=0;t<c;++t)m[h+t]+=e*f[u+t];h+=c,u+=c}}}}}}return u.toTensor()}depthwiseConv2DDerInput(t,a,n){r([t,a],"depthwiseConv2DDerInput");const s=e.buffer(n.inShape,"float32"),o=s.values,[i,l,d]=s.strides,h=this.readSync(t.dataId),[c,u,p]=t.strides,f=this.readSync(a.dataId),[m,y,g]=a.strides,{batchSize:S,filterHeight:I,filterWidth:b,inChannels:k,inHeight:M,inWidth:x,outChannels:A,outHeight:F,outWidth:v,strideHeight:D,strideWidth:T}=n,N=I-1-n.padInfo.top,w=b-1-n.padInfo.left,z=A/k;for(let t=0;t<S;++t)for(let e=0;e<k;++e)for(let a=0;a<M;++a){const r=a-N,n=Math.max(0,Math.ceil(r/D)),s=Math.min(F,(I+r)/D);for(let S=0;S<x;++S){const k=S-w,M=Math.max(0,Math.ceil(k/T)),x=Math.min(v,(b+k)/T);let A=0;for(let a=n;a<s;++a){const n=a*D-r;for(let r=M;r<x;++r){const s=c*t+u*a+p*r,o=m*(I-1-n)+y*(b-1-(r*T-k))+g*e;for(let t=0;t<z;++t){A+=h[s+(e*z+t)]*f[o+t]}}}o[i*t+l*a+d*S+e]=A}}return s.toTensor()}depthwiseConv2DDerFilter(t,a,n){r([t,a],"depthwiseConv2DDerFilter");const s=n.strideHeight,o=n.strideWidth,i=n.filterHeight,l=n.filterWidth,d=e.buffer(n.filterShape,"float32"),h=n.padInfo.left,c=n.padInfo.top,u=n.outChannels/n.inChannels,p=this.bufferSync(t),f=this.bufferSync(a);for(let t=0;t<i;++t){const e=Math.max(0,Math.ceil((c-t)/s)),a=Math.min(n.outHeight,(n.inHeight+c-t)/s);for(let r=0;r<l;++r){const i=Math.max(0,Math.ceil((h-r)/o)),l=Math.min(n.outWidth,(n.inWidth+h-r)/o);for(let m=0;m<n.outChannels;++m){const y=Math.trunc(m/u),g=m%u;let S=0;for(let d=0;d<n.batchSize;++d)for(let n=e;n<a;++n){const e=t+n*s-c;for(let t=i;t<l;++t){const a=r+t*o-h;S+=p.get(d,e,a,y)*f.get(d,n,t,m)}}d.set(S,t,r,y,g)}}}return d.toTensor()}tile(t,e){return r(t,"tile"),l(this.bufferSync(t),e)}pad(t,a,n){r(t,"pad");const s=a.map((e,a)=>e[0]+t.shape[a]+e[1]),o=a.map(t=>t[0]),i=this.bufferSync(t),l=e.buffer(s,t.dtype);0!==n&&l.values.fill(n);for(let e=0;e<t.size;e++){const t=i.indexToLoc(e),a=t.map((t,e)=>t+o[e]);l.set(i.get(...t),...a)}return l.toTensor()}gather(t,a,n){r([t,a],"gather");const s=t.shape.slice(),o=this.readSync(a.dataId);s[n]=o.length;const i=e.buffer(s,t.dtype),l=this.bufferSync(t);for(let t=0;t<i.size;++t){const e=i.indexToLoc(t),a=e.slice();a[n]=o[e[n]];const r=l.locToIndex(a);i.values[t]=l.values[r]}return i.toTensor()}batchToSpaceND(t,a,n){r([t],"batchToSpaceND");const s=a.reduce((t,e)=>t*e),o=e.backend_util.getReshaped(t.shape,a,s),i=e.backend_util.getPermuted(o.length,a.length),l=e.backend_util.getReshapedPermuted(t.shape,a,s),d=e.backend_util.getSliceBeginCoords(n,a.length),h=e.backend_util.getSliceSize(l,n,a.length);return e.transpose(t.reshape(o),i).reshape(l).slice(d,h)}spaceToBatchND(t,a,n){r([t],"spaceToBatchND");const s=a.reduce((t,e)=>t*e),o=[[0,0]];o.push(...n);for(let e=1+a.length;e<t.shape.length;++e)o.push([0,0]);const i=t.pad(o),l=e.backend_util.getReshaped(i.shape,a,s,!1),d=e.backend_util.getPermuted(l.length,a.length,!1),h=e.backend_util.getReshapedPermuted(i.shape,a,s,!1),c=e.transpose(i.reshape(l),d);return e.reshape(c,h)}maxPool(t,e){return r(t,"maxPool"),n(this.readSync(t.dataId),t.shape,t.dtype,t.strides,e,"max").toTensor()}maxPoolBackprop(t,a,n,o){r([a,n],"maxPoolBackprop");const i=this.readSync(a.dataId),l=e.buffer(o.outShape,a.dtype,s(i,a.shape,a.dtype,o).values),d=o.strideHeight,h=o.strideWidth,c=o.dilationHeight,u=o.dilationWidth,p=o.effectiveFilterHeight,f=o.effectiveFilterWidth,m=f-1-o.padInfo.left,y=p-1-o.padInfo.top,g=e.buffer(a.shape,"float32"),S=this.bufferSync(t);for(let t=0;t<o.batchSize;++t)for(let e=0;e<o.inChannels;++e)for(let a=0;a<o.inHeight;++a)for(let r=0;r<o.inWidth;++r){const n=a-y,s=r-m;let i=0;for(let a=0;a<p;a+=c){const r=(n+a)/d;if(!(r<0||r>=o.outHeight||Math.floor(r)!==r))for(let n=0;n<f;n+=u){const d=(s+n)/h;if(d<0||d>=o.outWidth||Math.floor(d)!==d)continue;const c=p*f-1-l.get(t,r,d,e)===a*f+n?1:0;0!==c&&(i+=S.get(t,r,d,e)*c)}}g.set(i,t,a,r,e)}return g.toTensor()}avgPoolBackprop(t,a,n){r([t,a],"avgPoolBackprop");const s=n.strideHeight,o=n.strideWidth,i=n.filterHeight,l=n.filterWidth,d=n.dilationHeight,h=n.dilationWidth,c=n.effectiveFilterHeight,u=n.effectiveFilterWidth,p=u-1-n.padInfo.left,f=c-1-n.padInfo.top,m=e.buffer(a.shape,"float32"),y=1/(i*l),g=this.bufferSync(t);for(let t=0;t<n.batchSize;++t)for(let e=0;e<n.inChannels;++e)for(let a=0;a<n.inHeight;++a)for(let r=0;r<n.inWidth;++r){const i=a-f,l=r-p;let S=0;for(let a=0;a<c;a+=d){const r=(i+a)/s;if(!(r<0||r>=n.outHeight||Math.floor(r)!==r))for(let a=0;a<u;a+=h){const s=(l+a)/o;s<0||s>=n.outWidth||Math.floor(s)!==s||(S+=g.get(t,r,s,e))}}m.set(S*y,t,a,r,e)}return m.toTensor()}pool3d(t,a,n){r(t,"pool3d");const s=a.strideDepth,o=a.strideHeight,i=a.strideWidth,l=a.dilationDepth,d=a.dilationHeight,h=a.dilationWidth,c=a.effectiveFilterDepth,u=a.effectiveFilterHeight,p=a.effectiveFilterWidth,f=a.padInfo.front,m=a.padInfo.top,y=a.padInfo.left,g="max"===n?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,S=this.readSync(t.dataId),I=e.buffer(a.outShape,t.dtype),b=I.values,k=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],M=a.outShape[2]*a.outShape[3]*a.outShape[4],x=a.outShape[3]*a.outShape[4],A=a.outShape[4];for(let e=0;e<a.batchSize;++e){const r=e*k,I=e*t.strides[0];for(let e=0;e<a.inChannels;++e)for(let k=0;k<a.outDepth;++k){const F=k*s-f;let v=F;for(;v<0;)v+=l;const D=Math.min(a.inDepth,c+F),T=r+k*M;for(let r=0;r<a.outHeight;++r){const s=r*o-m;let c=s;for(;c<0;)c+=d;const f=Math.min(a.inHeight,u+s),k=T+r*x;for(let r=0;r<a.outWidth;++r){const s=r*i-y;let o=s;for(;o<0;)o+=h;const u=Math.min(a.inWidth,p+s),m=k+r*A;let M=g,x=0,F=0;for(let a=v;a<D;a+=l){const r=I+a*t.strides[1];for(let a=c;a<f;a+=d){const s=r+a*t.strides[2];for(let a=o;a<u;a+=h){const r=S[s+a*t.strides[3]+e];if("max"===n&&r>M?M=r:"avg"===n&&(x+=r,F++),isNaN(M))break}if(isNaN(M))break}if(isNaN(M))break}b[m+e]="avg"===n?x/F:M}}}}return I.toTensor()}avgPool3d(t,e){return r(t,"avgPool3d"),this.pool3d(t,e,"avg").toFloat()}avgPool3dBackprop(t,a,n){r([t,a],"avgPool3dBackprop");const s=n.strideDepth,o=n.strideHeight,i=n.strideWidth,l=n.filterDepth,d=n.filterHeight,h=n.filterWidth,c=n.dilationDepth,u=n.dilationHeight,p=n.dilationWidth,f=n.effectiveFilterDepth,m=n.effectiveFilterHeight,y=n.effectiveFilterWidth,g=f-1-n.padInfo.front,S=y-1-n.padInfo.left,I=m-1-n.padInfo.top,b=e.buffer(a.shape,"float32"),k=1/(l*d*h),M=this.bufferSync(t);for(let t=0;t<n.batchSize;++t)for(let e=0;e<n.inChannels;++e)for(let a=0;a<n.inDepth;++a)for(let r=0;r<n.inHeight;++r)for(let l=0;l<n.inWidth;++l){const d=a-g,h=r-I,x=l-S;let A=0;for(let a=0;a<f;a+=c){const r=(d+a)/s;if(!(r<0||r>=n.outDepth||Math.floor(r)!==r))for(let a=0;a<m;a+=u){const s=(h+a)/o;if(!(s<0||s>=n.outHeight||Math.floor(s)!==s))for(let a=0;a<y;a+=p){const o=(x+a)/i;o<0||o>=n.outWidth||Math.floor(o)!==o||(A+=M.get(t,r,s,o,e))}}}b.set(A*k,t,a,r,l,e)}return b.toTensor()}maxPool3d(t,e){return r(t,"maxPool3d"),this.pool3d(t,e,"max").toFloat()}maxPool3dPositions(t,a){const r=e.buffer(a.outShape,"int32"),n=a.strideDepth,s=a.strideHeight,o=a.strideWidth,i=a.dilationDepth,l=a.dilationHeight,d=a.dilationWidth,h=a.effectiveFilterDepth,c=a.effectiveFilterHeight,u=a.effectiveFilterWidth,p=a.padInfo.front,f=a.padInfo.top,m=a.padInfo.left,y=this.bufferSync(t);for(let t=0;t<a.batchSize;++t)for(let e=0;e<a.inChannels;++e)for(let g=0;g<a.outDepth;++g){const S=g*n-p;let I=S;for(;I<0;)I+=i;const b=Math.min(a.inDepth,h+S);for(let n=0;n<a.outHeight;++n){const h=n*s-f;let p=h;for(;p<0;)p+=l;const k=Math.min(a.inHeight,c+h);for(let s=0;s<a.outWidth;++s){const f=s*o-m;let M=f;for(;M<0;)M+=d;const x=Math.min(a.inWidth,u+f);let A=Number.NEGATIVE_INFINITY,F=-1;for(let a=I;a<b;a+=i){const r=a-S;for(let n=p;n<k;n+=l){const s=n-h;for(let o=M;o<x;o+=d){const i=o-f,l=y.get(t,a,n,o,e);l>=A&&(A=l,F=r*c*u+s*c+i)}}}r.set(F,t,g,n,s,e)}}}return r.toTensor()}maxPool3dBackprop(t,a,n,s){r([a,n],"maxPool3dBackprop");const o=this.maxPool3dPositions(a,s),i=s.strideDepth,l=s.strideHeight,d=s.strideWidth,h=s.dilationDepth,c=s.dilationHeight,u=s.dilationWidth,p=s.effectiveFilterDepth,f=s.effectiveFilterHeight,m=s.effectiveFilterWidth,y=p-1-s.padInfo.front,g=m-1-s.padInfo.left,S=f-1-s.padInfo.top,I=e.buffer(a.shape,"float32"),b=this.bufferSync(o),k=this.bufferSync(t);for(let t=0;t<s.batchSize;++t)for(let e=0;e<s.inChannels;++e)for(let a=0;a<s.inDepth;++a)for(let r=0;r<s.inHeight;++r)for(let n=0;n<s.inWidth;++n){const o=a-y,M=r-S,x=n-g;let A=0;for(let a=0;a<p;a+=h){const r=(o+a)/i;if(!(r<0||r>=s.outDepth||Math.floor(r)!==r))for(let n=0;n<f;n+=c){const o=(M+n)/l;if(!(o<0||o>=s.outHeight||Math.floor(o)!==o))for(let i=0;i<m;i+=u){const l=(x+i)/d;if(l<0||l>=s.outWidth||Math.floor(l)!==l)continue;const h=p*f*m-1-b.get(t,r,o,l,e)===a*f*m+n*m+i?1:0;0!==h&&(A+=k.get(t,r,o,l,e)*h)}}}I.set(A,t,a,r,n,e)}return I.toTensor()}cast(t,a){return e.backend_util.castTensor(t,a,this)}reshape(t,a){return e.backend_util.reshapeTensor(t,a)}avgPool(t,e){return r(t,"avgPool"),r(t,"maxPool"),n(this.readSync(t.dataId),t.shape,t.dtype,t.strides,e,"avg").toTensor().toFloat()}resizeBilinear(t,a,n,s){r(t,"resizeBilinear");const[o,i,l,d]=t.shape,h=this.readSync(t.dataId),c=new Float32Array(e.util.sizeFromShape([o,a,n,d])),u=[s&&a>1?i-1:i,s&&n>1?l-1:l],p=[s&&a>1?a-1:a,s&&n>1?n-1:n];let f=0;const m=u[0]/p[0],y=u[1]/p[1];for(let e=0;e<o;e++)for(let r=0;r<a;r++){const a=m*r,s=Math.floor(a),o=a-s,u=Math.min(i-1,Math.ceil(a)),p=e*t.strides[0]+s*t.strides[1],g=e*t.strides[0]+u*t.strides[1];for(let e=0;e<n;e++){const a=y*e,r=Math.floor(a),n=a-r,s=Math.min(l-1,Math.ceil(a)),i=p+r*t.strides[2],u=g+r*t.strides[2],m=p+s*t.strides[2],S=g+s*t.strides[2];for(let t=0;t<d;t++){const e=h[i+t],a=h[u+t],r=e+(h[m+t]-e)*n,s=r+(a+(h[S+t]-a)*n-r)*o;c[f++]=s}}}return e.tensor(c,[o,a,n,d])}resizeBilinearBackprop(t,a,n){r([t,a],"resizeBilinearBackprop");const[s,o,i,l]=a.shape,[,d,h]=t.shape,c=new Float32Array(s*o*i*l),u=[n&&d>1?o-1:o,n&&h>1?i-1:i],p=[n&&d>1?d-1:d,n&&h>1?h-1:h],f=u[0]/p[0],m=u[1]/p[1],y=this.readSync(t.dataId);let g=0;for(let t=0;t<s;t++){const e=t*a.strides[0];for(let t=0;t<d;t++){const r=t*f,n=Math.floor(r),s=Math.min(Math.ceil(r),o-1),d=e+n*a.strides[1],u=e+s*a.strides[1],p=r-n,S=1-p;for(let t=0;t<h;t++){const e=t*m,r=Math.floor(e),n=Math.min(Math.ceil(e),i-1),s=e-r,o=1-s,h=d+r*a.strides[2],f=d+n*a.strides[2],I=u+r*a.strides[2],b=u+n*a.strides[2],k=S*o,M=S*s,x=p*o,A=p*s;for(let t=0;t<l;t++){const e=y[g++];c[h+t]+=e*k,c[f+t]+=e*M,c[I+t]+=e*x,c[b+t]+=e*A}}}}return e.tensor4d(c,[s,i,o,l],a.dtype)}resizeNearestNeighbor(t,a,n,s){r(t,"resizeNearestNeighbor");const[o,i,l,d]=t.shape,h=this.readSync(t.dataId),c=new Float32Array(o*a*n*d),u=[s&&a>1?i-1:i,s&&n>1?l-1:l],p=[s&&a>1?a-1:a,s&&n>1?n-1:n],f=u[0]/p[0],m=u[1]/p[1];let y=0;for(let e=0;e<o;e++){const r=e*t.strides[0];for(let e=0;e<a;e++){const a=f*e,o=r+Math.min(i-1,s?Math.round(a):Math.floor(a))*t.strides[1];for(let e=0;e<n;e++){const a=m*e,r=o+Math.min(l-1,s?Math.round(a):Math.floor(a))*t.strides[2];for(let t=0;t<d;t++){const e=h[r+t];c[y++]=e}}}}return e.tensor(c,[o,a,n,d],t.dtype)}resizeNearestNeighborBackprop(t,a,n){r([t,a],"resizeNearestNeighborBackprop");const[s,o,i,l]=a.shape,[,d,h]=t.shape,c=new Float32Array(s*o*i*l),u=this.readSync(t.dataId),p=[n&&d>1?o-1:o,n&&h>1?i-1:i],f=[n&&d>1?d-1:d,n&&h>1?h-1:h],m=p[0]/f[0],y=p[1]/f[1],g=1/m,S=1/y,I=2*Math.ceil(g)+2,b=2*Math.ceil(S)+2;for(let e=0;e<s;e++){const r=e*a.strides[0];for(let e=0;e<o;e++){const s=r+e*a.strides[1],p=Math.floor(e*g),f=Math.floor(p-I/2);for(let p=0;p<i;p++){const g=s+p*a.strides[2],k=Math.floor(p*S),M=Math.floor(k-b/2);for(let a=0;a<l;a++){let s=0;for(let l=0;l<I;l++){const c=l+f;if(c<0||c>=d)continue;const g=r+c*t.strides[1],S=c*m;if(e===Math.min(o-1,n?Math.round(S):Math.floor(S)))for(let e=0;e<b;e++){const r=e+M;if(r<0||r>=h)continue;const o=g+r*t.strides[2],l=r*y;p===Math.min(i-1,n?Math.round(l):Math.floor(l))&&(s+=u[o+a])}}c[g+a]=s}}}}return e.tensor4d(c,a.shape,a.dtype)}batchNorm(t,a,n,s,o,i){r([t,a,n,o,s],"batchNorm");const l=this.readSync(t.dataId),d=this.readSync(a.dataId),h=this.readSync(n.dataId),c=o?this.readSync(o.dataId):new Float32Array([1]),u=s?this.readSync(s.dataId):new Float32Array([0]),p=new Float32Array(l.length),f=u.length,m=c.length,y=h.length,g=d.length;let S=0,I=0,b=0,k=0;for(let t=0;t<l.length;++t)p[t]=u[S++]+(l[t]-d[I++])*c[b++]/Math.sqrt(h[k++]+i),S>=f&&(S=0),I>=g&&(I=0),b>=m&&(b=0),k>=y&&(k=0);return e.tensor4d(p,t.shape)}localResponseNormalization4D(t,a,n,s,o){r(t,"localResponseNormalization4D");const i=t.shape[3],l=i-1,d=this.readSync(t.dataId),h=t.size,c=new Float32Array(h);function u(t){const e=t%i;let r=t-e+Math.max(0,e-a);const n=t-e+Math.min(e+a,l);let s=0;for(;r<=n;r++){const t=d[r];s+=t*t}return s}for(let t=0;t<h;t++){const e=u(t),a=d[t]*Math.pow(n+s*e,-o);c[t]=a}return e.tensor4d(c,t.shape)}LRNGrad(t,a,n,s,o,i,l){r(t,"LRNGrad");const d=t.shape[3],h=this.readSync(t.dataId),c=this.readSync(a.dataId),u=this.readSync(n.dataId),p=new Float32Array(t.size),f=t.size;for(let t=0;t<f;t++){const e=t%d,a=t-e+Math.max(0,e-s),r=t-e+Math.min(d,e+s+1);let n=0;for(let t=a;t<r;t++)n+=Math.pow(c[t],2);n=i*n+o;for(let e=a;e<r;e++){let a=-2*i*l*c[e]*u[t]/n;t===e&&(a+=Math.pow(n,-l)),a*=h[t],p[e]+=a}}return e.tensor4d(p,t.shape)}multinomial(t,n,s,o){r(t,"multinomial");const i=n?t:e.softmax(t),l=i.shape[0],d=i.shape[1],h=e.zeros([l,s],"int32"),c=this.readSync(h.dataId),u=this.readSync(i.dataId);for(let t=0;t<l;++t){const e=t*d,r=new Float32Array(d-1);r[0]=u[e];for(let t=1;t<r.length;++t)r[t]=r[t-1]+u[e+t];const n=a.alea(o.toString()),i=t*s;for(let t=0;t<s;++t){const e=n();c[i+t]=r.length;for(let a=0;a<r.length;a++)if(e<r[a]){c[i+t]=a;break}}}return h}oneHot(t,a,n,s){r(t,"oneHot");const o=new Float32Array(t.size*a);o.fill(s);const i=this.readSync(t.dataId);for(let e=0;e<t.size;++e)i[e]>=0&&i[e]<a&&(o[e*a+i[e]]=n);return e.tensor2d(o,[t.size,a],"int32")}nonMaxSuppression(t,e,a,n,s){r(t,"nonMaxSuppression");const i=this.readSync(t.dataId),l=this.readSync(e.dataId);return o(i,l,a,n,s)}fft(t){return this.fftBatch(t,!1)}ifft(t){return this.fftBatch(t,!0)}fftBatch(t,a){const r=t.shape[0],n=t.shape[1],s=e.buffer(t.shape,"float32"),o=e.buffer(t.shape,"float32"),i=e.real(t).as2D(r,n),l=e.imag(t).as2D(r,n);for(let t=0;t<r;t++){const r=i.slice([t,0],[1,n]),d=l.slice([t,0],[1,n]),h=e.complex(r,d),c=this.readSync(this.fftImpl(h,a).dataId);for(let a=0;a<n;a++){const r=e.backend_util.getComplexWithIndex(c,a);s.values[t*n+a]=r.real,o.values[t*n+a]=r.imag}}return e.complex(s.toTensor(),o.toTensor()).as2D(r,n)}fftImpl(t,a){const r=t.as1D(),n=r.size;if(this.isExponentOf2(n)){let s=this.fftRadix2(r,n,a).as2D(t.shape[0],t.shape[1]);return a&&(s=e.complex(e.real(s).div(e.scalar(n)),e.imag(s).div(e.scalar(n)))),s}{const r=this.readSync(t.dataId),s=this.fourierTransformByMatmul(r,n,a),o=e.backend_util.splitRealAndImagArrays(s);return e.complex(o.real,o.imag).as2D(t.shape[0],t.shape[1])}}isExponentOf2(t){return 0==(t&t-1)}fftRadix2(t,a,r){if(1===a)return t;const n=this.readSync(t.dataId),s=a/2,o=e.backend_util.complexWithEvenIndex(n);let i=e.complex(o.real,o.imag).as1D();const l=e.backend_util.complexWithOddIndex(n);let d=e.complex(l.real,l.imag).as1D();i=this.fftRadix2(i,s,r),d=this.fftRadix2(d,s,r);const h=e.backend_util.exponents(a,r),c=e.complex(h.real,h.imag).mul(d),u=i.add(c),p=i.sub(c),f=e.real(u).concat(e.real(p)),m=e.imag(u).concat(e.imag(p));return e.complex(f,m).as1D()}fourierTransformByMatmul(t,a,r){const n=new Float32Array(2*a);for(let s=0;s<a;s++){let o=0,i=0;for(let n=0;n<a;n++){const l=e.backend_util.exponent(s*n,a,r),d=e.backend_util.getComplexWithIndex(t,n);o+=d.real*l.real-d.imag*l.imag,i+=d.real*l.imag+d.imag*l.real}r&&(o/=a,i/=a),e.backend_util.assignToTypedArray(n,o,i,s)}return n}depthToSpace(t,a,r){e.util.assert("NHWC"===r,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${r}`),e.util.assert(a>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`);const n=t.shape[0],s=t.shape[1],o=t.shape[2],i=t.shape[3],l=s*a,d=o*a,h=i/(a*a),c=this.readSync(t.dataId),u=new Float32Array(n*l*d*h);let p=0;for(let t=0;t<n;++t)for(let e=0;e<l;++e){const r=Math.floor(e/a),n=e%a;for(let e=0;e<d;++e){const l=Math.floor(e/a),d=(n*a+e%a)*h;for(let e=0;e<h;++e){const a=e+d+i*(l+o*(r+s*t));u[p++]=c[a]}}}return e.tensor4d(u,[n,l,d,h])}broadcastedBinaryOp(t,a,r,n){const s=e.backend_util.assertAndGetBroadcastShape(t.shape,a.shape),o=e.buffer(s,r),i=this.readSync(t.dataId),l=this.readSync(a.dataId),d=e.backend_util.getBroadcastDims(t.shape,s),h=e.backend_util.getBroadcastDims(a.shape,s),c=o.values;if(d.length+h.length===0)for(let t=0;t<c.length;++t)c[t]=n(i[t%i.length],l[t%l.length]);else{const e=this.bufferSync(t),r=this.bufferSync(a);for(let s=0;s<c.length;++s){const u=o.indexToLoc(s),p=u.slice(-t.rank);d.forEach(t=>p[t]=0);const f=e.locToIndex(p),m=u.slice(-a.rank);h.forEach(t=>m[t]=0);const y=r.locToIndex(m);c[s]=n(i[f],l[y])}}return o.toTensor()}broadcastedBinaryComplexOp(t,a,r){const n=e.backend_util.assertAndGetBroadcastShape(t.shape,a.shape),s=e.buffer(n,"float32"),o=e.buffer(n,"float32"),i=this.readSync(t.dataId),l=this.readSync(a.dataId),d=e.backend_util.getBroadcastDims(t.shape,n),h=e.backend_util.getBroadcastDims(a.shape,n),c=s.values,u=o.values;if(d.length+h.length===0)for(let t=0;t<c.length;t++){const e=t%i.length,a=t%l.length,n=r(i[2*e],i[2*e+1],l[2*a],l[2*a+1]);c[t]=n.real,u[t]=n.imag}else{const e=this.bufferSync(this.data.get(t.dataId).complexTensors.real),n=this.bufferSync(this.data.get(a.dataId).complexTensors.real);for(let o=0;o<c.length;o++){const p=s.indexToLoc(o),f=p.slice(-t.rank);d.forEach(t=>f[t]=0);const m=e.locToIndex(f),y=p.slice(-a.rank);h.forEach(t=>y[t]=0);const g=n.locToIndex(y),S=r(i[2*m],i[2*m+1],l[2*g],l[2*g+1]);c[o]=S.real,u[o]=S.imag}}return this.complex(s.toTensor(),o.toTensor())}split(t,e,a){return i(t,e,a)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}cropAndResize(t,a,r,n,s,o){const[i,l,d,h]=t.shape,c=a.shape[0],[u,p]=n,f=e.buffer([c,u,p,h],"float32"),m=this.readSync(a.dataId),y=this.readSync(r.dataId),g=this.readSync(t.dataId),S=t.strides,I=f.strides;for(let t=0;t<c;t++){const e=4*t,a=m[e],r=m[e+1],n=m[e+2],c=m[e+3],b=y[t];if(b>=i)continue;const k=u>1?(n-a)*(l-1)/(u-1):0,M=p>1?(c-r)*(d-1)/(p-1):0;for(let e=0;e<u;e++){const i=u>1?a*(l-1)+e*k:.5*(a+n)*(l-1);if(i<0||i>l-1)for(let a=0;a<p;a++)for(let r=0;r<h;r++){const n=r+a*I[2]+e*I[1]+t*I[0];f.values[n]=o}else if("bilinear"===s){const a=Math.floor(i),n=Math.ceil(i),s=i-a;for(let i=0;i<p;i++){const l=p>1?r*(d-1)+i*M:.5*(r+c)*(d-1);if(l<0||l>d-1){for(let a=0;a<h;a++){const r=a+i*I[2]+e*I[1]+t*I[0];f.values[r]=o}continue}const u=Math.floor(l),m=Math.ceil(l),y=l-u;for(let r=0;r<h;r++){let o=r+u*S[2]+a*S[1]+b*S[0];const l=g[o];o=r+m*S[2]+a*S[1]+b*S[0];const d=g[o];o=r+u*S[2]+n*S[1]+b*S[0];const h=g[o];o=r+m*S[2]+n*S[1]+b*S[0];const c=l+(d-l)*y,p=h+(g[o]-h)*y;o=r+i*I[2]+e*I[1]+t*I[0],f.values[o]=c+(p-c)*s}}}else for(let a=0;a<p;++a){const n=p>1?r*(d-1)+a*M:.5*(r+c)*(d-1);if(n<0||n>d-1){for(let r=0;r<h;r++){const n=r+a*I[2]+e*I[1]+t*I[0];f.values[n]=o}continue}const s=Math.round(n),l=Math.round(i);for(let r=0;r<h;r++){const n=r+s*S[2]+l*S[1]+b*S[0],o=r+a*I[2]+e*I[1]+t*I[0];f.values[o]=g[n]}}}}return f.toTensor()}sparseToDense(t,a,r,n){const{sliceRank:s,numUpdates:o,sliceSize:i,strides:l,outputSize:d}=e.backend_util.calculateShapes(a,t,r);return this.scatter(t,a,r,d,i,o,s,l,n,!1)}gatherND(t,a){const r=a.shape,n=r[r.length-1],[s,o,i,l]=e.backend_util.prepareAndValidate(t,a);if(0===o)return e.tensor([],s,t.dtype);const d=new e.TensorBuffer([o,i],t.dtype),h=this.readSync(a.dataId),c=this.readSync(t.dataId);for(let e=0;e<o;e++){const a=[];let r=0;for(let t=0;t<n;t++){const s=h[e*n+t];r+=s*l[t],a.push(s)}if(r<0||r>=t.size/i)throw new Error(`Invalid indices: ${a} does not index into ${t.shape}`);for(let t=0;t<i;t++)d.values[e*i+t]=c[r*i+t]}return d.toTensor().reshape(s)}scatterND(t,a,r){const{sliceRank:n,numUpdates:s,sliceSize:o,strides:i,outputSize:l}=e.backend_util.calculateShapes(a,t,r),d=e.scalar(0);return this.scatter(t,a,r,l,o,s,n,i,d,!0)}fill(t,a,r){r=r||e.util.inferDtype(a);const n=e.util.getArrayFromDType(r,e.util.sizeFromShape(t));return n.fill(a),e.engine().makeTensor(n,t,r,this)}onesLike(t){if("string"===t.dtype)throw new Error("onesLike is not supported for string tensors");return this.fill(t.shape,1,t.dtype)}zerosLike(t){const a=e.util.getArrayFromDType(t.dtype,e.util.sizeFromShape(t.shape));return this.makeOutput(a,t.shape,t.dtype)}linspace(t,a,r){return e.backend_util.linspaceImpl(t,a,r)}scatter(t,a,r,n,s,o,i,l,d,h){const c=[n/s,s],u=this.readSync(t.dataId),p=this.readSync(a.dataId);if(0===n)return e.tensor([],r,a.dtype);const f=new e.TensorBuffer(c,a.dtype);f.values.fill(this.readSync(d.dataId)[0]);for(let t=0;t<o;t++){const e=[];let o=0;for(let a=0;a<i;a++){const r=u[t*i+a];e.push(r),o+=r*l[a]}if(o<0||o>=n/s)throw new Error(`Invalid indices: ${e} does not index into ${r}`);for(let e=0;e<s;e++)h?f.values[o*s+e]+=p[t*s+e]:f.values[o*s+e]=0===a.rank?p[0]:p[t*s+e]}return f.toTensor().reshape(r)}}function p(t,a,r,n){const s=e.util.getTypedArrayFromDType(n,e.util.sizeFromShape(r));for(let e=0;e<s.length;++e){const r=e*a;let n=t[r];for(let e=0;e<a;++e){const a=t[r+e];a>n&&(n=a)}s[e]=n}return s}function f(t,a,r,n,s){const o=a.length,i=e.util.sizeFromShape(a),l=e.util.computeStrides(a),d=e.util.computeStrides(s),h=e.util.getTypedArrayFromDType(r,e.util.sizeFromShape(s));for(let a=0;a<i;++a){const r=e.util.indexToLoc(a,o,l),s=new Array(r.length);for(let t=0;t<s.length;t++)s[t]=r[n[t]];h[e.util.locToIndex(s,o,d)]=t[a]}return h}var m=Object.freeze({__proto__:null,maxImpl:p,transposeImpl:f});e.registerBackend("cpu",()=>new u,1);const y={kernelName:e.Dilation2D,backendName:"cpu",kernelFunc:({inputs:t,backend:a,attrs:r})=>{const{x:n,filter:s}=t,{strides:o,pad:i,dilations:l}=r,d=a,h=e.util.toNestedArray(n.shape,d.data.get(n.dataId).values),c=e.util.toNestedArray(s.shape,d.data.get(s.dataId).values),{batchSize:u,inHeight:p,inWidth:f,inChannels:m,outHeight:y,outWidth:g,padInfo:S,strideHeight:I,strideWidth:b,filterHeight:k,filterWidth:M,dilationHeight:x,dilationWidth:A,outShape:F}=e.backend_util.computeDilation2DInfo(n.shape,s.shape,o,i,"NHWC",l),v=e.util.makeZerosNestedTypedArray(F,n.dtype);for(let t=0;t<u;++t)for(let e=0;e<y;++e){const a=e*I-S.top;for(let r=0;r<g;++r){const n=r*b-S.left;for(let s=0;s<m;++s){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<k;++e){const r=a+e*x;if(r>=0&&r<p)for(let a=0;a<M;++a){const i=n+a*A;if(i>=0&&i<f){const n=h[t][r][i][s]+c[e][a][s];n>o&&(o=n)}}}v[t][e][r][s]=o}}}return{dataId:d.write(e.util.toTypedArray(v,n.dtype),F,n.dtype),shape:F,dtype:n.dtype}}},g={kernelName:e.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:t,backend:a,attrs:r})=>{const{x:n,filter:s,dy:o}=t,{strides:i,pad:l,dilations:d}=r,h=a,c=e.util.toNestedArray(n.shape,h.data.get(n.dataId).values),u=e.util.toNestedArray(s.shape,h.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:y,outHeight:g,outWidth:S,padInfo:I,strideHeight:b,strideWidth:k,filterHeight:M,filterWidth:x,dilationHeight:A,dilationWidth:F,outShape:v}=e.backend_util.computeDilation2DInfo(n.shape,s.shape,i,l,"NHWC",d);e.util.assert(o.rank===v.length,()=>`Error in ${e.Dilation2DBackpropFilter}, dy `+`must have the same rank as output ${v.length}, but got `+`${o.rank}`);const D=e.util.toNestedArray(v,h.data.get(o.dataId).values),T=e.util.makeZerosNestedTypedArray(s.shape,s.dtype);for(let t=0;t<p;++t)for(let e=0;e<g;++e){const a=e*b-I.top;for(let r=0;r<S;++r){const n=r*k-I.left;for(let s=0;s<y;++s){let o=Number.MIN_SAFE_INTEGER,i=0,l=0;for(let e=0;e<M;++e){const r=a+e*A;if(r>=0&&r<f)for(let a=0;a<x;++a){const d=n+a*F;if(d>=0&&d<m){const n=c[t][r][d][s]+u[e][a][s];n>o&&(o=n,i=e,l=a)}}}T[i][l][s]+=D[t][e][r][s]}}}return{dataId:h.write(e.util.toTypedArray(T,n.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},S={kernelName:e.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:t,backend:a,attrs:r})=>{const{x:n,filter:s,dy:o}=t,{strides:i,pad:l,dilations:d}=r,h=a,c=e.util.toNestedArray(n.shape,h.data.get(n.dataId).values),u=e.util.toNestedArray(s.shape,h.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:y,outHeight:g,outWidth:S,padInfo:I,strideHeight:b,strideWidth:k,filterHeight:M,filterWidth:x,dilationHeight:A,dilationWidth:F,outShape:v}=e.backend_util.computeDilation2DInfo(n.shape,s.shape,i,l,"NHWC",d);e.util.assert(o.rank===v.length,()=>`Error in ${e.Dilation2DBackpropInput}, dy `+`must have the same rank as output ${v.length}, but got `+`${o.rank}`);const D=e.util.toNestedArray(v,h.data.get(o.dataId).values),T=e.util.makeZerosNestedTypedArray(n.shape,n.dtype);for(let t=0;t<p;++t)for(let e=0;e<g;++e){const a=e*b-I.top;for(let r=0;r<S;++r){const n=r*k-I.left;for(let s=0;s<y;++s){let o=Number.MIN_SAFE_INTEGER,i=a<0?0:a,l=n<0?0:n;for(let e=0;e<M;++e){const r=a+e*A;if(r>=0&&r<f)for(let a=0;a<x;++a){const d=n+a*F;if(d>=0&&d<m){const n=c[t][r][d][s]+u[e][a][s];n>o&&(o=n,i=r,l=d)}}}T[t][i][l][s]+=D[t][e][r][s]}}}return{dataId:h.write(e.util.toTypedArray(T,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function I(t,e){return{kernelName:t,backendName:"cpu",kernelFunc:({inputs:a,backend:n})=>{const{a:s,b:o}=a,i=n;r([s,o],t);const l=i.data.get(s.dataId).values,d=i.data.get(o.dataId).values,[h,c]=e(s.shape,o.shape,l,d,s.dtype);return{dataId:i.write(h,c,s.dtype),shape:c,dtype:s.dtype}}}}function b(t){return(a,r,n,s,o)=>{const i=e.backend_util.assertAndGetBroadcastShape(a,r),l=i.length,d=e.util.computeStrides(i),h=e.util.sizeFromShape(i),c=e.util.getTypedArrayFromDType(o,h),u=a.length,p=r.length,f=e.util.computeStrides(a),m=e.util.computeStrides(r),y=e.backend_util.getBroadcastDims(a,i),g=e.backend_util.getBroadcastDims(r,i);if(y.length+g.length===0)for(let e=0;e<c.length;++e)c[e]=t(n[e%n.length],s[e%s.length]);else for(let a=0;a<c.length;++a){const r=e.util.indexToLoc(a,l,d),o=r.slice(-u);y.forEach(t=>o[t]=0);const i=e.util.locToIndex(o,u,f),h=r.slice(-p);g.forEach(t=>h[t]=0);const S=e.util.locToIndex(h,p,m);c[a]=t(n[i],s[S])}return[c,i]}}const k=b((t,e)=>t/e),M=I(e.Div,k),x={kernelName:e.FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:t,attrs:a,backend:r})=>{const{image:n}=t,s=r,o=e.util.getTypedArrayFromDType(n.dtype,e.util.sizeFromShape(n.shape)),[i,l,d,h]=n.shape,c=s.data.get(n.dataId).values;for(let t=0;t<i;t++){const e=t*d*l*h;for(let t=0;t<l;t++){const a=t*(d*h);for(let r=0;r<d;r++){const n=r*h;for(let s=0;s<h;s++){const l=[i,t,r,s][2],u=Math.round(d-l),p=e+a+n+s;let f=c[p];if(u>=0&&u<d){f=c[e+a+u*h+s]}o[p]=f}}}}return{dataId:s.write(o,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},A={kernelName:e.Max,backendName:"cpu",kernelFunc:({inputs:t,attrs:a,backend:n})=>{const{x:s}=t,{reductionIndices:o,keepDims:i}=a,l=n;let d=s.shape;const h=d.length,c=e.util.parseAxisParam(o,d);let u=c;const m=e.backend_util.getAxesPermutation(u,h);let y=l.data.get(s.dataId).values;if(null!=m){const t=new Array(h);for(let e=0;e<t.length;e++)t[e]=d[m[e]];y=f(y,d,s.dtype,m,t),u=e.backend_util.getInnerMostAxes(u.length,h),d=t}r(s,"max"),e.backend_util.assertAxesAreInnerMostDims("max",u,h);const[g,S]=e.backend_util.computeOutAndReduceShapes(d,u),I=p(y,e.util.sizeFromShape(S),g,s.dtype),b=l.write(I,g,s.dtype);let k=g;if(i){k=e.backend_util.expandShapeToKeepDim(g,c)}return{dataId:b,shape:k,dtype:s.dtype}}};const F={kernelName:e.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:t,attrs:a,backend:o})=>{const{x:i}=t,{filterSize:l,strides:d,pad:h,includeBatchInIndex:c}=a,u=o;r(i,"MaxPoolWithArgmax");const p=u.data.get(i.dataId).values,f=e.backend_util.computePool2DInfo(i.shape,l,d,[1,1],h),[m,y]=function(t,a,r,o,i){const l=n(t,0,r,e.util.computeStrides(a),i,"max"),d=s(t,a,r,i,!0,o);return[l.values,d.values]}(p,i.shape,i.dtype,c,f),g=u.write(m,f.outShape,i.dtype),S=u.write(y,f.outShape,i.dtype);return[{dataId:g,shape:f.outShape,dtype:i.dtype},{dataId:S,shape:f.outShape,dtype:"int32"}]}},v=e.kernel_impls.nonMaxSuppressionV4Impl,D={kernelName:e.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:a})=>{const{boxes:n,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:d}=a,h=e;r(n,"NonMaxSuppressionPadded");const c=h.data.get(n.dataId).values,u=h.data.get(s.dataId).values,{selectedIndices:p,validOutputs:f}=v(c,u,o,i,l,d);return[p,f]}},T=e.kernel_impls.nonMaxSuppressionV5Impl,N={kernelName:e.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:a})=>{const{boxes:n,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:d}=a,h=e;r(n,"NonMaxSuppressionWithScore");const c=h.data.get(n.dataId).values,u=h.data.get(s.dataId).values,p=o,f=i,m=l,y=d,{selectedIndices:g,selectedScores:S}=T(c,u,p,f,m,y);return[g,S]}},w={kernelName:e.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:t,attrs:a,backend:r})=>{const{image:n}=t,{radians:s,fillValue:o,center:i}=a,l=r,d=e.util.getTypedArrayFromDType(n.dtype,e.util.sizeFromShape(n.shape)),[h,c,u,p]=n.shape,[f,m]=e.backend_util.getImageCenter(i,c,u),y=Math.sin(s),g=Math.cos(s),S=l.data.get(n.dataId).values;for(let t=0;t<h;t++){const e=t*u*c*p;for(let t=0;t<c;t++){const a=t*(u*p);for(let r=0;r<u;r++){const n=r*p;for(let s=0;s<p;s++){const i=[h,t,r,s],l=i[2],I=i[1];let b=(l-f)*g-(I-m)*y,k=(l-f)*y+(I-m)*g;b=Math.round(b+f),k=Math.round(k+m);let M=o;if("number"!=typeof o&&(M=3===s?255:o[s]),b>=0&&b<u&&k>=0&&k<c){M=S[e+k*(u*p)+b*p+s]}d[e+a+n+s]=M}}}}return{dataId:l.write(d,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},z={kernelName:e.Square,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:a}=t,n=e;r(a,"square");const s=n.data.get(a.dataId).values,o=new Float32Array(s.length);for(let t=0;t<s.length;++t){const e=s[t];o[t]=e*e}return{dataId:n.write(o,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},W=b((t,e)=>{const a=t-e;return a*a}),H=[y,S,g,M,x,F,A,D,N,w,z,I(e.SquaredDifference,W),{kernelName:e.Transpose,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:a})=>{const{x:n}=t,{perm:s}=e,o=a;r(n,"transpose");const i=n.shape.length,l=new Array(i);for(let t=0;t<l.length;t++)l[t]=n.shape[s[t]];const d=f(o.data.get(n.dataId).values,n.shape,n.dtype,s,l);return{dataId:o.write(d,l,n.dtype),shape:l,dtype:n.dtype}}}];for(const t of H)e.registerKernel(t);t.MathBackendCPU=u,t.shared=m,t.version_cpu="2.3.0",Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-backend-cpu.es2017.min.js.map
